# ğŸš¨ 119 ì‹ ê³  ê±´ìˆ˜ ì˜ˆì¸¡ ëª¨ë¸ë§ (ë¶€ì‚°ê´‘ì—­ì‹œ)

## ğŸ“Œ í”„ë¡œì íŠ¸ ê°œìš”
ë³¸ í”„ë¡œì íŠ¸ëŠ” 2020ë…„ë¶€í„° 2023ë…„ê¹Œì§€ì˜ ë‹¤ì–‘í•œ ë°ì´í„°ë¥¼ ë°”íƒ•ìœ¼ë¡œ, **2024ë…„ ë¶€ì‚°ê´‘ì—­ì‹œì˜ í–‰ì •ë™ë³„ 119 ì‹ ê³  ê±´ìˆ˜(`call_count`)** ë¥¼ ì¼ ë‹¨ìœ„ë¡œ ì˜ˆì¸¡í•˜ëŠ” ë¨¸ì‹ ëŸ¬ë‹ ëª¨ë¸ì„ ê°œë°œí•œ ê²ƒì…ë‹ˆë‹¤.  
ë‹¨ìˆœ ê¸°ìƒ ë°ì´í„°ë¿ ì•„ë‹ˆë¼ **ì¸êµ¬, êµí†µì‚¬ê³ , ì‹œì •ê±°ë¦¬, ê³µê³µ ë‚ ì”¨ ë“± ì™¸ë¶€ ë°ì´í„°ë¥¼ í†µí•©**í•˜ì—¬ **ì‹œê³„ì—´ ë° ì§€ì—­ë³„ íŠ¹ì„±**ì„ ì •êµí•˜ê²Œ ë°˜ì˜í–ˆìŠµë‹ˆë‹¤.

---

## ğŸ§¾ 1. ì‚¬ìš© ë°ì´í„° ë° íŠ¹ì§•

### âœ… ê¸°ì´ˆ ë°ì´í„°
- **ë¶€ì‚°ì‹œ 119 ì‹ ê³  ë°ì´í„°** (2020~2023ë…„ ì¼ìë³„ í–‰ì •ë™ ê¸°ì¤€ ì‹ ê³  ê±´ìˆ˜)

### âœ… ì™¸ë¶€ ê³µê³µë°ì´í„° í†µí•©
- **ì¶”ê°€ ê¸°ìƒ ë°ì´í„°** (ê¸°ìƒì²­, ê¸°ìƒì‚°ì—…ì§„í¥ì› ë“±)
- **í–‰ì •ë™ë³„ ì¸êµ¬ ë°ì´í„°** (ì •ì£¼ì¸êµ¬, ìœ ë™ì¸êµ¬ í¬í•¨)
- **êµí†µì‚¬ê³  ë°ì´í„°** (ì¼ìë³„ ì‚¬ê³  ê±´ìˆ˜, ì‚¬ë§/ë¶€ìƒ)
- **ì‹œì •ê±°ë¦¬(ê°€ì‹œê±°ë¦¬) ë°ì´í„°** (ê´€ì¸¡ì†Œ ê¸°ì¤€)
- **ê³µíœ´ì¼ ì •ë³´, ìš”ì¼, ì£¼ë§ ì—¬ë¶€ ë“± ì‹œê°„ íŒŒìƒ ë³€ìˆ˜**

> ğŸ“Œ ë‹¤ì–‘í•œ ì™¸ë¶€ ë°ì´í„°ë¥¼ ë³‘í•©í•¨ìœ¼ë¡œì¨ **ì‹ ê³  ê±´ìˆ˜ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆëŠ” ê°„ì ‘ ìš”ì¸ë“¤**ì„ ì˜ˆì¸¡ ëª¨ë¸ì— ë°˜ì˜í–ˆìŠµë‹ˆë‹¤.

---

## ğŸ§¼ 2. ë°ì´í„° ì „ì²˜ë¦¬ ë° ì •ì œ

### âœ… ê¸°ë³¸ ì²˜ë¦¬
```python
df = pd.read_csv('2020_2023_ìµœì¢…ë°ì´í„°.csv')
df.drop(columns=['tm_dt', 'address_city'], inplace=True)
df['datetime'] = pd.to_datetime(df['tm'], format='%Y%m%d')
```
- ë¶ˆí•„ìš”í•œ ì»¬ëŸ¼ ì œê±° (tm_dt, address_city)
- ë‚ ì§œ ì»¬ëŸ¼ì„ datetime í¬ë§·ìœ¼ë¡œ ë³€í™˜

### âœ… ëˆ„ë½ëœ ë‚ ì§œ-ë™ ì¡°í•© ì²˜ë¦¬
```python
# ëª¨ë“  ë‚ ì§œ-í–‰ì •ë™ ì¡°í•© ìƒì„± í›„ ë³‘í•©
full_index = pd.MultiIndex.from_product([...])
df = full_df.merge(df, on=['tm', 'address_gu', 'sub_address'], how='left')
df['call_count'] = df['call_count'].fillna(0)
```
- ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë‚ ì§œ-í–‰ì •ë™ ì¡°í•©ì€ ì‹ ê³  ê±´ìˆ˜ 0ìœ¼ë¡œ ì±„ì›€

---

## ğŸ§  3. í”¼ì²˜ ì—”ì§€ë‹ˆì–´ë§

### âœ… ì‹œê°„ ê¸°ë°˜ í”¼ì²˜ ìƒì„±
```python
df['day'] = df['datetime'].dt.day
df['weekday'] = df['datetime'].dt.weekday
df['is_weekend'] = df['weekday'].isin([5, 6]).astype(int)
df['month_sin'] = np.sin(2 * np.pi * df['datetime'].dt.month / 12)
df['month_cos'] = np.cos(2 * np.pi * df['datetime'].dt.month / 12)
```
- ì£¼ê¸°ì  íŠ¹ì„±(ì›”, ìš”ì¼)ì„ sin/cosìœ¼ë¡œ ì¸ì½”ë”©
- ì£¼ë§ ì—¬ë¶€, ê³µíœ´ì¼ ì „í›„ ì—¬ë¶€ë„ íŒŒìƒ

### âœ… ì‹œê³„ì—´ ê¸°ë°˜ í”¼ì²˜
```python
df['dong_lag_1'] = df.groupby(['address_gu', 'sub_address'])['call_count'].shift(1)
df['dong_rolling_mean_7'] = df.groupby(['address_gu', 'sub_address'])['call_count'].shift(1).rolling(window=7).mean()
```
- ì‹ ê³  ê±´ìˆ˜ì˜ ìµœê·¼ 1ì¼, 7ì¼ í‰ê· , í‘œì¤€í¸ì°¨ ë“± ìƒì„±
- í•´ë‹¹ ë™ ê¸°ì¤€ì˜ ì‹œê³„ì—´ íŠ¹ì„±ì„ ëª¨ë¸ì— ë°˜ì˜

### âœ… íƒ€ê²Ÿ ì¸ì½”ë”©
```python
gu_mean_map = y_train.groupby(X_train_full['address_gu']).mean()
X_train_full['address_gu_mean_target'] = X_train_full['address_gu'].map(gu_mean_map)
```
- í–‰ì •êµ¬ë³„ í‰ê·  ì‹ ê³  ê±´ìˆ˜ë¥¼ íŒŒìƒ ë³€ìˆ˜ë¡œ ìƒì„±
- ì§€ì—­ë³„ ìˆ˜ìš” ì°¨ì´ë¥¼ ëª¨ë¸ì´ í•™ìŠµ ê°€ëŠ¥í•˜ë„ë¡ ë³´ì™„

---

## ğŸ§ª 4. ê²€ì¦ ë°ì´í„° ë¶„í• 

- ì‹œê³„ì—´ íŠ¹ì„±ì„ ê³ ë ¤í•˜ì—¬ **ì‹œê°„ ìˆœì„œ ê¸°ì¤€ìœ¼ë¡œ 80:20 ë¶„í• **
```python
X_train, X_val, y_train, y_val = train_test_split(..., test_size=0.2, shuffle=False)
```
- ê²€ì¦ ë°ì´í„°ëŠ” ì•½ 2023ë…„ ì´ˆ~ë§ êµ¬ê°„ì˜ ë°ì´í„°ë¥¼ í¬í•¨
- í•™ìŠµ ë° ê²€ì¦ì…‹ì€ ì‹œê°„ ìˆœì„œ ê¸°ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ëˆ„ìˆ˜ ë°©ì§€

## ğŸ¤– 5. ëª¨ë¸ êµ¬ì„± ë° í•™ìŠµ ë°©ì‹

âœ… XGBoost íšŒê·€ ëª¨ë¸
```python
model = XGBRegressor(
    n_estimators=1000,
    learning_rate=0.05,
    max_depth=6,
    tree_method='hist',
    early_stopping_rounds=30,
)
```
- ë¹„ì„ í˜•ì„±ì— ê°•í•œ XGBoost íšŒê·€ ëª¨ë¸ í™œìš©
- í•™ìŠµì€ ì „ì²´ ë°ì´í„°ë¡œ, ê²€ì¦ì€ ì§€ì—­ë³„ë¡œ ë”°ë¡œ ìˆ˜í–‰

### âœ… êµ¬ ë‹¨ìœ„ ëª¨ë¸ í•™ìŠµ
```python
for gu in gu_train.unique():
    model = XGBRegressor(**params)
    model.fit(X_train, y_train, eval_set=[(X_val_gu, y_val_gu)])
```
- ê° í–‰ì •êµ¬(address_gu) ë‹¨ìœ„ë¡œ ê°œë³„ ëª¨ë¸ì„ ë”°ë¡œ í•™ìŠµ
- íŠ¹ì • ì§€ì—­ì— ë§ëŠ” íŒ¨í„´ì„ ê°œë³„ì ìœ¼ë¡œ ë°˜ì˜í•  ìˆ˜ ìˆìŒ

### âœ… Optuna ê¸°ë°˜ í•˜ì´í¼íŒŒë¼ë¯¸í„° íŠœë‹
```python
def objective(trial, ...):
    params = {
        'max_depth': trial.suggest_int('max_depth', 5, 12),
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.2, log=True),
        ...
    }
```
- Optuna ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í†µí•´ ìë™ìœ¼ë¡œ ìµœì  íŒŒë¼ë¯¸í„° íƒìƒ‰
- í‰ê°€ ê¸°ì¤€ì€ Validation RMSE ìµœì†Œí™”

### âœ… ì˜ˆì¸¡ ë³´ì •
```python
scaled_pred = pred * 0.8
clipped_pred = np.clip(scaled_pred, 1, 6)
final_pred = round(clipped_pred)
```
- ê³¼ëŒ€ ì˜ˆì¸¡ ë°©ì§€ë¥¼ ìœ„í•´ ì˜ˆì¸¡ê°’ì„ ìŠ¤ì¼€ì¼ ì¡°ì • í›„ í´ë¦¬í•‘

## ğŸ“ˆ 6. ì„±ëŠ¥ í‰ê°€

| í•­ëª©               | ì„¤ëª…                                                    |
|--------------------|---------------------------------------------------------|
| **ìµœì¢… RMSE (ê²€ì¦ì…‹)** | 1.05 (Optuna íŠœë‹ í›„, ì „ì²´ ê²€ì¦ ë°ì´í„° ê¸°ì¤€)              |
| **RÂ² Score**        | ì „ì²´ ê²€ì¦ ë°ì´í„° ê¸°ì¤€ **0.90+ í™•ë³´**                   |
| **ì˜ˆì¸¡ê°’ ë³´ì • ë°©ì‹**| 0.8 ìŠ¤ì¼€ì¼ë§ í›„ 1~6 ë²”ìœ„ë¡œ í´ë¦¬í•‘ ë° ë°˜ì˜¬ë¦¼             |


## ğŸ›  7. ê°œë°œ ë° ì‹¤í–‰ í™˜ê²½

- **ê°œë°œ í™˜ê²½**: Google Colab (GPU ê°€ì† ì—†ì´ë„ ì‹¤í–‰ ê°€ëŠ¥)
- **Python ë²„ì „**: 3.10 ì´ìƒ
- **ì£¼ìš” ë¼ì´ë¸ŒëŸ¬ë¦¬**:
  - xgboost==1.7.6
  - scikit-learn==1.3.2
  - optuna
  - pandas
  - numpy
  - joblib
  - tqdm

